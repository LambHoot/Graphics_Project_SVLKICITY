#version 330 core

uniform vec3 viewPos;

//from vertex shader
in vec3 world_pos;
in vec3 world_normal;
in vec4 viewSpace;

in vec3 frag_Color;
in vec3 out_normal;
in vec3 InterNormal;

out vec3 color;


const vec3 fogColor = vec3(0.5, 0.5,0.5);
const float FogDensity = 0.001;

const vec3 DiffuseLight = vec3(0.15, 0.05, 0.0);
const vec3 light_position = vec3(500.0f, 1000.0f, 500.0f);
const vec3 light_colour = vec3(1.0f, 1.0f, 0.0f);

const float specularStrength = 0.5f;

void main(){
	vec3 finalColor = vec3(0, 0, 0);

	vec3 L = normalize( light_position - world_pos);
	vec3 diffuse = vec3(1.0f, 1.0f, 0.0f) * max(0, dot(L, (normalize(world_normal))));
	//vec3 diffuse = DiffuseLight * dot(L,out_normal);

	//vec3 mycolour = frag_Color * diffuse;//frag_Color * normalize(diffuse);
	
	//if(mycolour.z <= 0.5 && mycolour.x <= 0.5 && mycolour.y <= 0.5)
	//{
	//	mycolour = vec3(1.0f, 1.0f, 1.0f);
	//}

	vec3 viewDir = normalize(viewPos - world_pos);
	vec3 reflectDir = reflect(-L, normalize(world_normal));

	float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);
	vec3 specular = specularStrength * spec * light_colour; 

	vec3 lightColor = frag_Color * (diffuse + specular);//vec3(max(0,out_normal.x + 1.0f), max(0,out_normal.y + 0.5f), max(0,out_normal.z + 0.5f));
	


	//distance
	float dist = 0;
	float fogFactor = 0;
	//range based
	dist = length(viewSpace);

	fogFactor = 1.0 /exp(dist * FogDensity);
	fogFactor = clamp( fogFactor, 0.0, 1.0 );
 
	//if you inverse color in glsl mix function you have to
	//put 1.0 - fogFactor
	finalColor = mix(fogColor, lightColor, fogFactor);

	color = finalColor;
}